{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"OmegaConf Plugin - Cloud Resolvers","text":"<p>This package is a plugin designed to enhance OmegaConf by providing additional custom resolvers to securely retrieve sensitive values that should not be hard-coded in your configuration files.</p>"},{"location":"#abstract","title":"Abstract","text":"<p>Having code in production is always challenging, and reports like the one provided by Unit42 from Palo Alto Networks are proof of them.</p> <p>This plugin is an attempt to mitigate this problem, letting you move your secrets from any file (like an <code>.env</code>) to a more secure place, so they are retrieved only when needed.</p> <p>The following diagram depicts the main idea in an AWS environment:</p> <p> </p> <p>It is built on top of OmegaConf, hence it can be also used together with Hydra. To check out the examples using Hydra, go to Integration with Hydra</p> <p>Currently, the following cloud services are supported:</p> <ul> <li>AWS Secrets Manager</li> <li>AWS Parameter Store</li> <li>GCP Secret Manager</li> </ul>"},{"location":"#collaborate","title":"Collaborate","text":"<p>If you thing something is missing or not working fine, just let us know in GitHub.</p>"},{"location":"api/register/","title":"Register Custom Resolvers","text":""},{"location":"api/register/#omegaconf_cloud_resolvers.register_custom_resolvers","title":"<code>register_custom_resolvers(*args, **kwargs)</code>","text":"<p>Registers multiple custom resolvers at once for OmegaConf.</p> <p>This function allows you to register multiple custom resolvers either by passing them as positional arguments or as keyword arguments. If only a callable is provided, the name used to register the callable will be its function name. If there are any name collisions between the positional and keyword arguments, a ValueError will be raised.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <code>Callable[..., JsonType]</code> <p>Variable length list of callables to register as resolvers.</p> <code>()</code> <code>**kwargs</code> <code>Dict[str, Callable[..., JsonType]]</code> <p>Arbitrary keyword arguments where the key is the name of the resolver and the value is the callable.</p> <code>{}</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If there are any name collisions between the positional and keyword arguments.</p> Example <pre><code>def custom_resolver1():\n    return \"value1\"\ndef custom_resolver2():\n    return \"value2\"\nregister_custom_resolvers(custom_resolver1, custom_resolver2=my_custom_resolver2)\n</code></pre> Source code in <code>omegaconf_cloud_resolvers/__init__.py</code> <pre><code>def register_custom_resolvers(\n    *args: Callable[..., JsonType], **kwargs: Dict[str, Callable[..., JsonType]]\n):\n    \"\"\"\n    Registers multiple custom resolvers at once for OmegaConf.\n\n    This function allows you to register multiple custom resolvers either by passing them as positional arguments\n    or as keyword arguments. If only a callable is provided, the name used to register the callable will be its\n    function name. If there are any name collisions between the positional and keyword arguments, a ValueError\n    will be raised.\n\n    Args:\n        *args: Variable length list of callables to register as resolvers.\n        **kwargs: Arbitrary keyword arguments where the key is the name of the resolver and the value is the callable.\n\n    Raises:\n        ValueError: If there are any name collisions between the positional and keyword arguments.\n\n    Example:\n        ```python\n        def custom_resolver1():\n            return \"value1\"\n        def custom_resolver2():\n            return \"value2\"\n        register_custom_resolvers(custom_resolver1, custom_resolver2=my_custom_resolver2)\n        ```\n    \"\"\"\n\n    def _get_callable_name(func: Callable):\n        return func.__name__\n\n    def _get_collision_keys(dict1: Dict[str, Any], dict2: Dict[str, Any]):\n        # Convert the dictionary keys to sets\n        keys1 = set(dict1.keys())\n        keys2 = set(dict2.keys())\n        shared_keys = keys1.intersection(keys2)\n        return shared_keys\n\n    args_expand = {_get_callable_name(x): x for x in args}\n    resolvers = {**args_expand, **kwargs}\n    collision_keys = _get_collision_keys(args_expand, kwargs)\n    if collision_keys:\n        raise ValueError(\n            f\"Collision name on resolvers: {collision_keys}, provide key-word for those function with the same name\"\n        )\n    i = 0  # needed in case of no injection\n    for i, (name, func) in enumerate(resolvers.items(), 1):\n        name = name or _get_callable_name(func)\n        OmegaConf.register_new_resolver(name, func)\n    logger.info(\"Custom resolvers registered: %s\", i)\n</code></pre>"},{"location":"api/resolvers/aws/parameterstore/","title":"AWS Parameter Store","text":"<p>               Bases: <code>PluginResolver</code>, <code>AWSParameterStoreMixin</code></p> <p>Resolver for AWS Systems Manager Parameter Store</p> <p>Methods:</p> Name Description <code>__init__</code> <p>Initializes the resolver with a boto3 Session. If no Session is provided, it'll be infered from the default credentials, if configured.</p> <code>__call__</code> <p>Resolves the secret by its name and returns the decoded secret data.</p> Example <p>Example 1: Retrieve a secret as a string providing a custom session <pre><code>&gt;&gt;&gt; resolver = AWSParameterStoreResolver(session=boto3_session)\n&gt;&gt;&gt; parameter_value = resolver('my/parameter/name') # Contains 1 value\n&gt;&gt;&gt; print(parameter_value)\n</code></pre> Example 2: Retrieve a StringList and try to cast the types <pre><code>&gt;&gt;&gt; resolver = AWSParameterStoreResolver(infer_types=True)\n&gt;&gt;&gt; parameter_value = resolver('my/parameter/list/name') # Contains 1 value\n&gt;&gt;&gt; print(parameter_value)\n</code></pre> Example 3: Retrieve a family of parameters without recursion (i.e. 1 level) <pre><code>&gt;&gt;&gt; resolver = AWSParameterStoreResolver()\n&gt;&gt;&gt; parameter_value = resolver('my/parameter/family/*')\n&gt;&gt;&gt; print(parameter_value)\n</code></pre> Example 4: Retrieve a family of parameters with recursion <pre><code>&gt;&gt;&gt; resolver = AWSParameterStoreResolver()\n&gt;&gt;&gt; parameter_value = resolver('my/parameter/family/**')\n&gt;&gt;&gt; print(parameter_value)\n</code></pre></p> Source code in <code>omegaconf_cloud_resolvers/resolvers/aws/parameterstore.py</code> <pre><code>class AWSParameterStoreResolver(PluginResolver, AWSParameterStoreMixin):\n    \"\"\"\n    Resolver for AWS Systems Manager Parameter Store\n\n    Methods:\n        __init__(session=None, decrypt=True, infer_types=False, *args, **kwargs):\n            Initializes the resolver with a boto3 Session.\n            If no Session is provided, it'll be infered from the default credentials,\n            if configured.\n\n        __call__(name):\n            Resolves the secret by its name and returns the decoded secret data.\n\n    Example:\n        Example 1: Retrieve a secret as a string providing a custom session\n        ```python\n        &gt;&gt;&gt; resolver = AWSParameterStoreResolver(session=boto3_session)\n        &gt;&gt;&gt; parameter_value = resolver('my/parameter/name') # Contains 1 value\n        &gt;&gt;&gt; print(parameter_value)\n        ```\n        Example 2: Retrieve a StringList and try to cast the types\n        ```python\n        &gt;&gt;&gt; resolver = AWSParameterStoreResolver(infer_types=True)\n        &gt;&gt;&gt; parameter_value = resolver('my/parameter/list/name') # Contains 1 value\n        &gt;&gt;&gt; print(parameter_value)\n        ```\n        Example 3: Retrieve a family of parameters without recursion (i.e. 1 level)\n        ```python\n        &gt;&gt;&gt; resolver = AWSParameterStoreResolver()\n        &gt;&gt;&gt; parameter_value = resolver('my/parameter/family/*')\n        &gt;&gt;&gt; print(parameter_value)\n        ```\n        Example 4: Retrieve a family of parameters with recursion\n        ```python\n        &gt;&gt;&gt; resolver = AWSParameterStoreResolver()\n        &gt;&gt;&gt; parameter_value = resolver('my/parameter/family/**')\n        &gt;&gt;&gt; print(parameter_value)\n        ```\n    \"\"\"\n\n    def __init__(\n        self,\n        session: Session = None,\n        decrypt: bool = True,\n        infer_types: bool = False,\n        *args,\n        **kwargs,\n    ):\n        \"\"\"\n        Initializes the AWSParameterStoreResolver.\n\n        Args:\n            session: An optional boto3 session to use for AWS interactions.\n            decrypt: If True, attempts to decrypt SecureString parameters.\n            infer_types: If True, attempts to infer the type of the parameter value, it might be\n                more useful when the parameter is of type StringList if mixed types are found.\n        \"\"\"\n        super().__init__(session, *args, **kwargs)\n        self._decrypt = decrypt\n        self._infer_types = infer_types\n\n    def __call__(self, name: str) -&gt; JsonType:\n        \"\"\"\n        Retrieves a parameter from AWS Systems Manager Parameter Store.\n\n        Args:\n            name: The name of the parameter to retrieve.\n                Retrieve a single parameter,\n\n        Returns:\n            The parameter value. If the parameter is a StringList and _decrypt is False,\n                                         it returns a list of strings or numbers (if _infer_types is True).\n                                         Otherwise, it returns the parameter value as a string, int, or float\n                                         depending on the type inference.\n        \"\"\"\n        if name.endswith(\"/*\") or name.endswith(\"/**\"):\n            if name.endswith(\n                \"/**\"\n            ):  # If '**' access recursively, if only '*' just to the first level.\n                recursive = True\n                name = name.removesuffix(\"/**\")\n            else:\n                recursive = False\n                name = name.removesuffix(\"/*\")\n            return self._get_path_parameters(name, recursive)\n        else:\n            return self._get_single_parameter(name)\n\n    def _get_single_parameter(self, name: str) -&gt; JsonType:\n        value = self.client.get_parameter(Name=name, WithDecryption=self._decrypt)\n        ptype = value[\"Parameter\"][\"Type\"]\n        pvalue = value[\"Parameter\"][\"Value\"]\n        return self._parse_value(pvalue, ptype, self._decrypt, self._infer_types)\n\n    def _get_path_parameters(self, name: str, recursive: bool = False) -&gt; JsonType:\n        rparameters = []\n        # Use the get_parameters_by_path method to retrieve parameters\n        response = self.client.get_parameters_by_path(\n            Path=name, Recursive=recursive, WithDecryption=self._decrypt\n        )\n        rparameters.extend(response[\"Parameters\"])\n\n        # Check if there are more parameters to retrieve\n        while \"NextToken\" in response:\n            response = self._decrypt.get_parameters_by_path(\n                Path=name,\n                Recursive=recursive,\n                WithDecryption=self._decrypt,\n                NextToken=response[\"NextToken\"],\n            )\n            rparameters.extend(response[\"Parameters\"])\n\n        parameters = {}\n        for parameter in rparameters:\n            pname, ptype, pvalue = (\n                parameter[\"Name\"],\n                parameter[\"Type\"],\n                parameter[\"Value\"],\n            )\n            pname = pname.replace(name, \"\").lstrip(\"/\")\n            parameters[pname] = self._parse_value(\n                value=pvalue,\n                type_=ptype,\n                decrypt=self._decrypt,\n                infer_types=self._infer_types,\n            )\n        return parameters\n\n    @staticmethod\n    def _parse_value(\n        value: str,\n        type_: AWS_PARAMETER_TYPE,\n        decrypt: bool = False,\n        infer_types: bool = False,\n    ) -&gt; JsonType:\n        \"\"\"\n        Parses the parameter value based on its type and the provided flags.\n\n        Args:\n            value (str): The parameter value to parse.\n            type_ (Literal[\"String\", \"StringList\", \"SecureString\"]): The type of the parameter.\n            decrypt (bool): A flag indicating whether the parameter value should be decrypted, for \"String\", \"StringList\",\n              it does make any difference. For \"SecureString\", if False, it returns the encrypted string.\n            infer_types (bool): A flag indicating whether to attempt to infer and cast the type of the parameter value.\n              Note: it does not strip strings, so \"a,b, c\" will return [\"a\", \"b\", \" c\"]\n\n        Returns:\n            The parsed parameter value. If the parameter is a StringList and decrypt is False,\n            it returns a list of strings or numbers (if infer_types is True).\n            Otherwise, it returns the parameter value as a string, int, or float\n            depending on the type inference.\n        \"\"\"\n\n        if type_ == \"StringList\":\n            values = value.split(\",\")\n            if infer_types:\n                return [try_infer_and_cast(v) for v in values]\n            else:\n                return values\n\n        if type_ == \"SecureString\" and not decrypt:\n            if infer_types:\n                logger.warning(\n                    \"infer_types is ignored when parameter type is 'SecureString' and decrypt is False\"\n                )\n            return value  # returns the encrypted value\n\n        if infer_types:\n            return try_infer_and_cast(value)\n        else:\n            return value\n</code></pre>","tags":["AWS"]},{"location":"api/resolvers/aws/parameterstore/#omegaconf_cloud_resolvers.resolvers.aws.AWSParameterStoreResolver.__call__","title":"<code>__call__(name)</code>","text":"<p>Retrieves a parameter from AWS Systems Manager Parameter Store.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the parameter to retrieve. Retrieve a single parameter,</p> required <p>Returns:</p> Type Description <code>JsonType</code> <p>The parameter value. If the parameter is a StringList and _decrypt is False,                          it returns a list of strings or numbers (if _infer_types is True).                          Otherwise, it returns the parameter value as a string, int, or float                          depending on the type inference.</p> Source code in <code>omegaconf_cloud_resolvers/resolvers/aws/parameterstore.py</code> <pre><code>def __call__(self, name: str) -&gt; JsonType:\n    \"\"\"\n    Retrieves a parameter from AWS Systems Manager Parameter Store.\n\n    Args:\n        name: The name of the parameter to retrieve.\n            Retrieve a single parameter,\n\n    Returns:\n        The parameter value. If the parameter is a StringList and _decrypt is False,\n                                     it returns a list of strings or numbers (if _infer_types is True).\n                                     Otherwise, it returns the parameter value as a string, int, or float\n                                     depending on the type inference.\n    \"\"\"\n    if name.endswith(\"/*\") or name.endswith(\"/**\"):\n        if name.endswith(\n            \"/**\"\n        ):  # If '**' access recursively, if only '*' just to the first level.\n            recursive = True\n            name = name.removesuffix(\"/**\")\n        else:\n            recursive = False\n            name = name.removesuffix(\"/*\")\n        return self._get_path_parameters(name, recursive)\n    else:\n        return self._get_single_parameter(name)\n</code></pre>","tags":["AWS"]},{"location":"api/resolvers/aws/parameterstore/#omegaconf_cloud_resolvers.resolvers.aws.AWSParameterStoreResolver.__init__","title":"<code>__init__(session=None, decrypt=True, infer_types=False, *args, **kwargs)</code>","text":"<p>Initializes the AWSParameterStoreResolver.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>Session</code> <p>An optional boto3 session to use for AWS interactions.</p> <code>None</code> <code>decrypt</code> <code>bool</code> <p>If True, attempts to decrypt SecureString parameters.</p> <code>True</code> <code>infer_types</code> <code>bool</code> <p>If True, attempts to infer the type of the parameter value, it might be more useful when the parameter is of type StringList if mixed types are found.</p> <code>False</code> Source code in <code>omegaconf_cloud_resolvers/resolvers/aws/parameterstore.py</code> <pre><code>def __init__(\n    self,\n    session: Session = None,\n    decrypt: bool = True,\n    infer_types: bool = False,\n    *args,\n    **kwargs,\n):\n    \"\"\"\n    Initializes the AWSParameterStoreResolver.\n\n    Args:\n        session: An optional boto3 session to use for AWS interactions.\n        decrypt: If True, attempts to decrypt SecureString parameters.\n        infer_types: If True, attempts to infer the type of the parameter value, it might be\n            more useful when the parameter is of type StringList if mixed types are found.\n    \"\"\"\n    super().__init__(session, *args, **kwargs)\n    self._decrypt = decrypt\n    self._infer_types = infer_types\n</code></pre>","tags":["AWS"]},{"location":"api/resolvers/aws/secretsmanager/","title":"AWS Secrets Manager","text":"<p>               Bases: <code>PluginResolver</code>, <code>AWSSecretManagerMixin</code></p> <p>Resolver for the AWS Secrets Manager</p> <p>Methods:</p> Name Description <code>__init__</code> <p>Initializes the resolver with a boto3 Session. If no Session is provided, it'll be infered from the default credentials, if configured.</p> <code>__call__</code> <p>Resolves the secret by its name and returns the decoded secret data.</p> Example <p>Example 1: Retrieve a secret as a string <pre><code>&gt;&gt;&gt; resolver = AWSSecretsManagerResolver(session=boto3_session, infer_json=True)\n&gt;&gt;&gt; secret_value = resolver('my_secret')\n&gt;&gt;&gt; print(secret_value) # {\"a\": 1}\n</code></pre></p> <p>Example 2: Retrieve a secret and parse it as JSON <pre><code>&gt;&gt;&gt; resolver = AWSSecretsManagerResolver(session=boto3_session, infer_json=False)\n&gt;&gt;&gt; secret_value = resolver('my_secret')\n&gt;&gt;&gt; print(secret_value) # '{\"a\": 1}'\n</code></pre></p> Source code in <code>omegaconf_cloud_resolvers/resolvers/aws/secretsmanager.py</code> <pre><code>class AWSSecretsManagerResolver(PluginResolver, AWSSecretManagerMixin):\n    \"\"\"\n    Resolver for the AWS Secrets Manager\n\n    Methods:\n        __init__(session=None, infer_json=False, return_binary=False, *args, **kwargs):\n            Initializes the resolver with a boto3 Session.\n            If no Session is provided, it'll be infered from the default credentials,\n            if configured.\n\n        __call__(name):\n            Resolves the secret by its name and returns the decoded secret data.\n\n    Example:\n        Example 1: Retrieve a secret as a string\n        ```python\n        &gt;&gt;&gt; resolver = AWSSecretsManagerResolver(session=boto3_session, infer_json=True)\n        &gt;&gt;&gt; secret_value = resolver('my_secret')\n        &gt;&gt;&gt; print(secret_value) # {\"a\": 1}\n        ```\n\n        Example 2: Retrieve a secret and parse it as JSON\n        ```python\n        &gt;&gt;&gt; resolver = AWSSecretsManagerResolver(session=boto3_session, infer_json=False)\n        &gt;&gt;&gt; secret_value = resolver('my_secret')\n        &gt;&gt;&gt; print(secret_value) # '{\"a\": 1}'\n        ```\n\n\n    \"\"\"\n\n    def __init__(\n        self,\n        session=None,\n        infer_json: bool = False,\n        return_binary: bool = False,\n        *args,\n        **kwargs,\n    ):\n        \"\"\"\n        Initializes the AWSSecretsManagerResolver.\n\n        Args:\n            session (boto3.Session): boto3.Session to use for AWS interactions. If none provided, tries to use the default configuration.\n            infer_json: If True, tries to parse the secret as JSON during the __call__.\n            return_binary: If True, tries to return the binary value from the key `SecretBinary` instead of `SecretString`.\n        \"\"\"\n        super().__init__(session, *args, **kwargs)\n        self._infer_json = infer_json\n        self._return_binary = return_binary\n        if self._return_binary and self._infer_json:\n            logger.warning(\"infer_json is only tried for string secrets\")\n\n    def __call__(self, name: str) -&gt; JsonType:\n        \"\"\"\n        Retrieves a secret from AWS Secrets Manager.\n        The default behaviour prioritizes 'SecretString' over 'SecretBinary'\n\n        Args:\n            name: The name of the secret to retrieve.\n\n        Returns:\n            The secret value. If infer_json is True and the secret is a valid JSON string,\n                         it returns a dictionary. Otherwise, it returns the secret as a string.\n\n        Raises:\n            KeyError: If the secret does not contain either of \"SecretString\", \"SecretBinary\" key.\n        \"\"\"\n\n        secret = self.client.get_secret_value(SecretId=name)\n\n        try:\n            if self._return_binary:\n                return secret[\"SecretBinary\"]\n            else:\n                secret = secret[\"SecretString\"]\n                if self._infer_json:\n                    return try_cast_to_dict(secret)\n                else:\n                    return secret\n        except KeyError as e:\n            logger.exception(\"The found secret does not contain '%s'\", e.args[0])\n            raise\n</code></pre>","tags":["AWS"]},{"location":"api/resolvers/aws/secretsmanager/#omegaconf_cloud_resolvers.resolvers.aws.AWSSecretsManagerResolver.__call__","title":"<code>__call__(name)</code>","text":"<p>Retrieves a secret from AWS Secrets Manager. The default behaviour prioritizes 'SecretString' over 'SecretBinary'</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the secret to retrieve.</p> required <p>Returns:</p> Type Description <code>JsonType</code> <p>The secret value. If infer_json is True and the secret is a valid JSON string,          it returns a dictionary. Otherwise, it returns the secret as a string.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the secret does not contain either of \"SecretString\", \"SecretBinary\" key.</p> Source code in <code>omegaconf_cloud_resolvers/resolvers/aws/secretsmanager.py</code> <pre><code>def __call__(self, name: str) -&gt; JsonType:\n    \"\"\"\n    Retrieves a secret from AWS Secrets Manager.\n    The default behaviour prioritizes 'SecretString' over 'SecretBinary'\n\n    Args:\n        name: The name of the secret to retrieve.\n\n    Returns:\n        The secret value. If infer_json is True and the secret is a valid JSON string,\n                     it returns a dictionary. Otherwise, it returns the secret as a string.\n\n    Raises:\n        KeyError: If the secret does not contain either of \"SecretString\", \"SecretBinary\" key.\n    \"\"\"\n\n    secret = self.client.get_secret_value(SecretId=name)\n\n    try:\n        if self._return_binary:\n            return secret[\"SecretBinary\"]\n        else:\n            secret = secret[\"SecretString\"]\n            if self._infer_json:\n                return try_cast_to_dict(secret)\n            else:\n                return secret\n    except KeyError as e:\n        logger.exception(\"The found secret does not contain '%s'\", e.args[0])\n        raise\n</code></pre>","tags":["AWS"]},{"location":"api/resolvers/aws/secretsmanager/#omegaconf_cloud_resolvers.resolvers.aws.AWSSecretsManagerResolver.__init__","title":"<code>__init__(session=None, infer_json=False, return_binary=False, *args, **kwargs)</code>","text":"<p>Initializes the AWSSecretsManagerResolver.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>Session</code> <p>boto3.Session to use for AWS interactions. If none provided, tries to use the default configuration.</p> <code>None</code> <code>infer_json</code> <code>bool</code> <p>If True, tries to parse the secret as JSON during the call.</p> <code>False</code> <code>return_binary</code> <code>bool</code> <p>If True, tries to return the binary value from the key <code>SecretBinary</code> instead of <code>SecretString</code>.</p> <code>False</code> Source code in <code>omegaconf_cloud_resolvers/resolvers/aws/secretsmanager.py</code> <pre><code>def __init__(\n    self,\n    session=None,\n    infer_json: bool = False,\n    return_binary: bool = False,\n    *args,\n    **kwargs,\n):\n    \"\"\"\n    Initializes the AWSSecretsManagerResolver.\n\n    Args:\n        session (boto3.Session): boto3.Session to use for AWS interactions. If none provided, tries to use the default configuration.\n        infer_json: If True, tries to parse the secret as JSON during the __call__.\n        return_binary: If True, tries to return the binary value from the key `SecretBinary` instead of `SecretString`.\n    \"\"\"\n    super().__init__(session, *args, **kwargs)\n    self._infer_json = infer_json\n    self._return_binary = return_binary\n    if self._return_binary and self._infer_json:\n        logger.warning(\"infer_json is only tried for string secrets\")\n</code></pre>","tags":["AWS"]},{"location":"api/resolvers/az/keyvault/","title":"Azure Key Vault","text":"<p>               Bases: <code>PluginResolver</code>, <code>AzureKeyVaulMixin</code></p> <p>Resolver for the Azure Key Vault.</p> <p>Methods:</p> Name Description <code>__init__</code> <p>Initializes the resolver with optional credentials. If no credential is provided, they'll be infered from the default credentials, if condigured.</p> <code>__call__</code> <p>Resolves the secret by its name and returns the decoded secret data.</p> Example <p>Example 1: retrieve a given version of your secret <pre><code>&gt;&gt;&gt; from azure.identity import DefaultAzureCredential\n&gt;&gt;&gt; my_credentials = DefaultAzureCredential()\n&gt;&gt;&gt; resolver = AzureKeyVaultResolver(credentials=my_credentials)\n&gt;&gt;&gt; secret_data = resolver(\"keyvault/MyKeyVault123/secret/SecretName/version/339d8635b22344b2b6117588ef94a22q\")\n&gt;&gt;&gt; print(secret_data)\n</code></pre></p> <p>Example 2: retrieve the latest version of your secret <pre><code>&gt;&gt;&gt; resolver = AzureKeyVaultResolver()\n&gt;&gt;&gt; secret_data = resolver(\"keyvault/MyKeyVault123/secret/SecretName\")\n&gt;&gt;&gt; print(secret_data)\n</code></pre></p> Source code in <code>omegaconf_cloud_resolvers/resolvers/az/keyvault.py</code> <pre><code>class AzureKeyVaultResolver(PluginResolver, AzureKeyVaulMixin):\n    \"\"\"\n    Resolver for the Azure Key Vault.\n\n    Methods:\n        __init__(credential=None, *args, **kwargs):\n            Initializes the resolver with optional credentials.\n            If no credential is provided, they'll be infered from the default credentials,\n            if condigured.\n\n        __call__(name):\n            Resolves the secret by its name and returns the decoded secret data.\n\n    Example:\n        Example 1: retrieve a given version of your secret\n        ```python\n        &gt;&gt;&gt; from azure.identity import DefaultAzureCredential\n        &gt;&gt;&gt; my_credentials = DefaultAzureCredential()\n        &gt;&gt;&gt; resolver = AzureKeyVaultResolver(credentials=my_credentials)\n        &gt;&gt;&gt; secret_data = resolver(\"keyvault/MyKeyVault123/secret/SecretName/version/339d8635b22344b2b6117588ef94a22q\")\n        &gt;&gt;&gt; print(secret_data)\n        ```\n\n        Example 2: retrieve the latest version of your secret\n        ```python\n        &gt;&gt;&gt; resolver = AzureKeyVaultResolver()\n        &gt;&gt;&gt; secret_data = resolver(\"keyvault/MyKeyVault123/secret/SecretName\")\n        &gt;&gt;&gt; print(secret_data)\n        ```\n    \"\"\"\n\n    def __call__(self, name: str) -&gt; str:\n        \"\"\"\n        Resolves the secret by its name and returns the decoded secret data.\n\n        Args:\n            name (str): The name of the secret to resolve.\n                Names must follow the following syntax:\n                `keyvault/&lt;keyvault_id&gt;/secret/&lt;secret_name&gt;`,\n                 `keyvault/&lt;keyvault_id&gt;/secret/&lt;secret_name&gt;/version/&lt;version&gt;`\n\n        Returns:\n            (str): The secret data.\n\n        Raises:\n            ValueError: If the secret name cannot be parsed or if required components are missing.\n\n        \"\"\"\n        name_fields = self._parse_secret_name(name)\n        response = self.client(\n            keyvault=name_fields[\"keyvault\"],\n            secret=name_fields[\"secret\"],\n            version=name_fields[\"version\"],\n        )\n        return response.value\n\n    def _parse_secret_name(self, name: str) -&gt; Dict[str, str]:\n        \"\"\"\n        Parses the secret name and returns a dictionary with the necessary components.\n\n        Args:\n            name (str): The name of the secret to parse.\n\n        Returns:\n            Dict[str, str]: A dictionary containing the components of the secret name.\n\n        Raises:\n            ValueError: If the secret name cannot be parsed or if required components are missing.\n        \"\"\"\n        secret_dict = {}\n        if \"/\" not in name:\n            raise ValueError(\n                \"You must provide at least `keyvault/&lt;keyvault_id&gt;/secret/&lt;secret_id&gt;`\"\n            )\n\n        secret_comps = iter(name.split(\"/\"))\n        try:\n            secret_dict = {k: v for k, v in zip(secret_comps, secret_comps)}\n        except Exception:\n            ValueError(\"Failure parsing secret name.\")\n\n        if not {\"secret\", \"keyvault\"}.issubset(secret_dict.keys()):\n            raise ValueError(\n                \"You must provide at least `keyvault/&lt;keyvault_id&gt;/secret/&lt;secret_id&gt;`\"\n            )\n        if \"version\" not in secret_dict.keys():\n            secret_dict[\"version\"] = None\n        return secret_dict\n</code></pre>","tags":["AZ"]},{"location":"api/resolvers/az/keyvault/#omegaconf_cloud_resolvers.resolvers.az.AzureKeyVaultResolver.__call__","title":"<code>__call__(name)</code>","text":"<p>Resolves the secret by its name and returns the decoded secret data.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the secret to resolve. Names must follow the following syntax: <code>keyvault/&lt;keyvault_id&gt;/secret/&lt;secret_name&gt;</code>,  <code>keyvault/&lt;keyvault_id&gt;/secret/&lt;secret_name&gt;/version/&lt;version&gt;</code></p> required <p>Returns:</p> Type Description <code>str</code> <p>The secret data.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the secret name cannot be parsed or if required components are missing.</p> Source code in <code>omegaconf_cloud_resolvers/resolvers/az/keyvault.py</code> <pre><code>def __call__(self, name: str) -&gt; str:\n    \"\"\"\n    Resolves the secret by its name and returns the decoded secret data.\n\n    Args:\n        name (str): The name of the secret to resolve.\n            Names must follow the following syntax:\n            `keyvault/&lt;keyvault_id&gt;/secret/&lt;secret_name&gt;`,\n             `keyvault/&lt;keyvault_id&gt;/secret/&lt;secret_name&gt;/version/&lt;version&gt;`\n\n    Returns:\n        (str): The secret data.\n\n    Raises:\n        ValueError: If the secret name cannot be parsed or if required components are missing.\n\n    \"\"\"\n    name_fields = self._parse_secret_name(name)\n    response = self.client(\n        keyvault=name_fields[\"keyvault\"],\n        secret=name_fields[\"secret\"],\n        version=name_fields[\"version\"],\n    )\n    return response.value\n</code></pre>","tags":["AZ"]},{"location":"api/resolvers/gcp/secretmanager/","title":"GCP Secret Manager","text":"<p>               Bases: <code>PluginResolver</code>, <code>GCPSecretManagerMixin</code></p> <p>Resolver for the GCP Secret Manager.</p> <p>Methods:</p> Name Description <code>__init__</code> <p>Initializes the resolver with optional credentials, project ID, and encoding. If no credentials or project_id are provided, they'll be infered from the default credentials, if condigured.</p> <code>__call__</code> <p>Resolves the secret by its name and returns the decoded secret data.</p> Example <p>Example 1: <pre><code>&gt;&gt;&gt; resolver = GCPSecretManagerResolver(credentials=my_credentials, project_id=\"my_project\")\n&gt;&gt;&gt; secret_data = resolver(\"projects/my_project/secrets/my_secret/versions/latest\")\n&gt;&gt;&gt; print(secret_data)\n</code></pre></p> <p>Example 2: retrieve the latest version of your secret while infering the project <pre><code>&gt;&gt;&gt; resolver = GCPSecretManagerResolver()\n&gt;&gt;&gt; secret_data = resolver(\"my_secret\")\n&gt;&gt;&gt; print(secret_data)\n</code></pre></p> <p>Example 3: retrieve a given version of your secret while infering the project <pre><code>&gt;&gt;&gt; resolver = GCPSecretManagerResolver()\n&gt;&gt;&gt; secret_data = resolver(\"secrets/my_secret/versions/1\")\n&gt;&gt;&gt; print(secret_data)\n</code></pre></p> Source code in <code>omegaconf_cloud_resolvers/resolvers/gcp/secretmanager.py</code> <pre><code>class GCPSecretManagerResolver(PluginResolver, GCPSecretManagerMixin):\n    \"\"\"\n    Resolver for the GCP Secret Manager.\n\n    Methods:\n        __init__(credentials=None, project_id=None, encoding=\"UTF-8\", *args, **kwargs):\n            Initializes the resolver with optional credentials, project ID, and encoding.\n            If no credentials or project_id are provided, they'll be infered from the default credentials,\n            if condigured.\n\n        __call__(name):\n            Resolves the secret by its name and returns the decoded secret data.\n\n    Example:\n        Example 1:\n        ```python\n        &gt;&gt;&gt; resolver = GCPSecretManagerResolver(credentials=my_credentials, project_id=\"my_project\")\n        &gt;&gt;&gt; secret_data = resolver(\"projects/my_project/secrets/my_secret/versions/latest\")\n        &gt;&gt;&gt; print(secret_data)\n        ```\n\n        Example 2: retrieve the latest version of your secret while infering the project\n        ```python\n        &gt;&gt;&gt; resolver = GCPSecretManagerResolver()\n        &gt;&gt;&gt; secret_data = resolver(\"my_secret\")\n        &gt;&gt;&gt; print(secret_data)\n        ```\n\n        Example 3: retrieve a given version of your secret while infering the project\n        ```python\n        &gt;&gt;&gt; resolver = GCPSecretManagerResolver()\n        &gt;&gt;&gt; secret_data = resolver(\"secrets/my_secret/versions/1\")\n        &gt;&gt;&gt; print(secret_data)\n        ```\n    \"\"\"\n\n    def __init__(\n        self,\n        credentials=None,\n        project_id: str = None,\n        encoding: str = \"UTF-8\",\n        *args,\n        **kwargs,\n    ):\n        \"\"\"\n        Initializes the GCPSecretManagerResolver.\n\n        Args:\n            credentials (google.auth.credentials.Crendential): The google.auth.credentials.Crendential to\n                access GCP Secret Manager. If none provided, and uses the default project configured locally.\n            project_id: The GCP project ID. If none provided, tries to use the default project configured locally.\n            encoding: The encoding used to decode the secret data.\n        \"\"\"\n        super().__init__(credentials, project_id, *args, **kwargs)\n        self.encoding = encoding\n\n    def __call__(self, name: str) -&gt; JsonType:\n        \"\"\"\n        Resolves the secret by its name and returns the decoded secret data.\n\n        Args:\n            name (str): The name of the secret to resolve.\n                Names must follow the following syntax: `&lt;secret_name&gt;`, `secrets/&lt;secret_name&gt;`,\n                `secrets/&lt;secret_name&gt;/versions/&lt;version&gt;`,\n                 `projects/&lt;project-id&gt;/secrets/&lt;secret_name&gt;/versions/&lt;version&gt;`\n\n        Returns:\n            (str): The decoded secret data.\n\n        Raises:\n            ValueError: If the secret name cannot be parsed or if required components are missing.\n\n        \"\"\"\n        name_fields = self._parse_secret_name(name)\n        secret_name = self._build_secret_name(**name_fields)\n        response = self.client.access_secret_version(request={\"name\": secret_name})\n        return response.payload.data.decode(self.encoding)\n\n    def _parse_secret_name(self, name: str) -&gt; Dict[str, str]:\n        \"\"\"\n        Parses the secret name and returns a dictionary with the necessary components.\n\n        Args:\n            name (str): The name of the secret to parse.\n\n        Returns:\n            Dict[str, str]: A dictionary containing the components of the secret name.\n\n        Raises:\n            ValueError: If the secret name cannot be parsed or if required components are missing.\n        \"\"\"\n        if \"/\" in name:\n            # Handle cases like projects/projectA/secrets/secretID, secrets/secretID\n            secret_comps = iter(name.split(\"/\"))\n            try:\n                secret_dict = {k: v for k, v in zip(secret_comps, secret_comps)}\n            except Exception:\n                ValueError(\"Failure parsing secret name.\")\n        else:\n            # Handles if just 'secretID' is provided\n            secret_dict = {\"secrets\": name}\n\n        if \"secrets\" not in secret_dict.keys():\n            raise ValueError(\"You must provide at least `secrets/&lt;secret_id&gt;`\")\n        if \"projects\" not in secret_dict.keys():\n            secret_dict[\"projects\"] = self._project_id\n        if \"versions\" not in secret_dict.keys():\n            secret_dict[\"versions\"] = \"latest\"\n\n        return secret_dict\n\n    @staticmethod\n    def _build_secret_name(projects: str, secrets: str, versions: str) -&gt; str:\n        \"\"\"\n        Constructs the full secret name from its components.\n\n        Args:\n            projects (str): The GCP project ID.\n            secrets (str): The secret ID.\n            versions (str): The version of the secret.\n\n        Returns:\n            str: The full secret name in the format 'projects/{projects}/secrets/{secrets}/versions/{versions}'.\n        \"\"\"\n        return f\"projects/{projects}/secrets/{secrets}/versions/{versions}\"\n</code></pre>","tags":["GCP"]},{"location":"api/resolvers/gcp/secretmanager/#omegaconf_cloud_resolvers.resolvers.gcp.GCPSecretManagerResolver.__call__","title":"<code>__call__(name)</code>","text":"<p>Resolves the secret by its name and returns the decoded secret data.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the secret to resolve. Names must follow the following syntax: <code>&lt;secret_name&gt;</code>, <code>secrets/&lt;secret_name&gt;</code>, <code>secrets/&lt;secret_name&gt;/versions/&lt;version&gt;</code>,  <code>projects/&lt;project-id&gt;/secrets/&lt;secret_name&gt;/versions/&lt;version&gt;</code></p> required <p>Returns:</p> Type Description <code>str</code> <p>The decoded secret data.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the secret name cannot be parsed or if required components are missing.</p> Source code in <code>omegaconf_cloud_resolvers/resolvers/gcp/secretmanager.py</code> <pre><code>def __call__(self, name: str) -&gt; JsonType:\n    \"\"\"\n    Resolves the secret by its name and returns the decoded secret data.\n\n    Args:\n        name (str): The name of the secret to resolve.\n            Names must follow the following syntax: `&lt;secret_name&gt;`, `secrets/&lt;secret_name&gt;`,\n            `secrets/&lt;secret_name&gt;/versions/&lt;version&gt;`,\n             `projects/&lt;project-id&gt;/secrets/&lt;secret_name&gt;/versions/&lt;version&gt;`\n\n    Returns:\n        (str): The decoded secret data.\n\n    Raises:\n        ValueError: If the secret name cannot be parsed or if required components are missing.\n\n    \"\"\"\n    name_fields = self._parse_secret_name(name)\n    secret_name = self._build_secret_name(**name_fields)\n    response = self.client.access_secret_version(request={\"name\": secret_name})\n    return response.payload.data.decode(self.encoding)\n</code></pre>","tags":["GCP"]},{"location":"api/resolvers/gcp/secretmanager/#omegaconf_cloud_resolvers.resolvers.gcp.GCPSecretManagerResolver.__init__","title":"<code>__init__(credentials=None, project_id=None, encoding='UTF-8', *args, **kwargs)</code>","text":"<p>Initializes the GCPSecretManagerResolver.</p> <p>Parameters:</p> Name Type Description Default <code>credentials</code> <code>Crendential</code> <p>The google.auth.credentials.Crendential to access GCP Secret Manager. If none provided, and uses the default project configured locally.</p> <code>None</code> <code>project_id</code> <code>str</code> <p>The GCP project ID. If none provided, tries to use the default project configured locally.</p> <code>None</code> <code>encoding</code> <code>str</code> <p>The encoding used to decode the secret data.</p> <code>'UTF-8'</code> Source code in <code>omegaconf_cloud_resolvers/resolvers/gcp/secretmanager.py</code> <pre><code>def __init__(\n    self,\n    credentials=None,\n    project_id: str = None,\n    encoding: str = \"UTF-8\",\n    *args,\n    **kwargs,\n):\n    \"\"\"\n    Initializes the GCPSecretManagerResolver.\n\n    Args:\n        credentials (google.auth.credentials.Crendential): The google.auth.credentials.Crendential to\n            access GCP Secret Manager. If none provided, and uses the default project configured locally.\n        project_id: The GCP project ID. If none provided, tries to use the default project configured locally.\n        encoding: The encoding used to decode the secret data.\n    \"\"\"\n    super().__init__(credentials, project_id, *args, **kwargs)\n    self.encoding = encoding\n</code></pre>","tags":["GCP"]},{"location":"first/install/","title":"Installation","text":"<p>You can install the package only with the required dependencies for your environment.</p> <p>Using <code>pip</code>:</p> <ul> <li>For AWS:</li> </ul> <pre><code>pip install omegaconf-cloud-resolvers[aws]\n</code></pre> <ul> <li>For GCP</li> </ul> <pre><code>pip install omegaconf-cloud-resolvers[gcp]\n</code></pre> <ul> <li>For Azure</li> </ul> <pre><code>pip install omegaconf-cloud-resolvers[az]\n</code></pre>"},{"location":"first/install/#hydra","title":"Hydra","text":"<p>If you make use of <code>hydra</code> to load your configuration as well, it needs to be installed separately:</p> <pre><code>pip install hydra-core\n</code></pre>"},{"location":"users-guide/integration-hydra/","title":"Integration with Hydra","text":"<p>If you are new to Hydra, you might want to have a look at the docs. Hydra is a powerful framework for configuring complex applications. It allows you to compose configurations dynamically and provides a flexible way to manage them To use Hydra, ensure that it is installed in your environment. If it is not installed, you can do so by running the following command:</p> <pre><code>pip install -U hydra-core\n</code></pre> <p>In this example, we will demonstrate how to use Hydra in conjunction with the AWS environment and the AWS SSM Parameter Store.</p>"},{"location":"users-guide/integration-hydra/#set-up-the-permissions","title":"Set-up the Permissions","text":""},{"location":"users-guide/integration-hydra/#credentials-and-permissions","title":"Credentials and Permissions","text":"<p>If you are running this example from your local machine, ensure that you have configured your AWS credentials.</p> <p>You might need to install the aws-cli if you don't have it yet.</p> <p>To verify that you have the necessary permissions to access the AWS SSM Parameter Store and to create and retrieve parameters, review the policies attached to your user's role. Ensure that your IAM user or role has the appropriate permissions.</p>"},{"location":"users-guide/integration-hydra/#configuring-aws-cli","title":"Configuring AWS CLI","text":"<p>After installing the AWS CLI, configure it with your credentials by running:</p> <p><pre><code>aws configure\n</code></pre> You will be prompted to enter your AWS Access Key ID, Secret Access Key, region, and output format. This configuration is stored in the <code>~/.aws/credentials</code> and <code>~/.aws/config</code> files.</p>"},{"location":"users-guide/integration-hydra/#example","title":"Example","text":""},{"location":"users-guide/integration-hydra/#create-a-secret-parameter","title":"Create a secret parameter.","text":"<p>To create a secret parameter using the AWS CLI, run the following command:</p> <pre><code>aws ssm put-parameter --name \"/projectBlue/envA/secret\" --value \"MySecureParameterValue\" --type \"SecureString\"\n</code></pre> <p>Make sure to keep the parameter's name handy, as we will use it later in our configuration file.</p>"},{"location":"users-guide/integration-hydra/#write-your-script","title":"Write your script","text":"<p>Create a <code>main.py</code> file with the following content:</p> <pre><code>import hydra\nfrom omegaconf import DictConfig\nimport boto3\nfrom omegaconf_cloud_resolvers import register_custom_resolvers\nfrom omegaconf_cloud_resolvers.resolvers.aws import AWSParameterStoreResolver\n\nsession = boto3.Session(...)  # Replace ... with you actual auth info, e.g: profile_name\n\nresolvers = {\n    \"get_aws_secret\": AWSParameterStoreResolver(session=session),\n}\n\nregister_custom_resolvers(**resolvers)\n\nconfig_fname = \"config\"\nconfig_dir = \".\"\n\n\n@hydra.main(version_base=None, config_path=config_dir, config_name=config_fname)\ndef main(cfg: DictConfig):\n    print(cfg[\"secret\"])\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <p>Let's understand each line step by step.</p> <ol> <li>Define the resolver to retrieve the secret.    Each key in the <code>resolvers</code> dictionary will be the name of the function that you can use in your configuration files.    The dictionary's value must be a callable, which in this case, it is, since all the cloud resolvers are    provided with a <code>__call__</code> method.</li> </ol> <pre><code>resolvers = {\n    \"get_aws_secret\": AWSSecretsManagerResolver(session=session),\n}\n</code></pre> <ol> <li>Register the resolvers using the function <code>register_custom_resolvers</code>.    This step is what will ensure that you can access your secret using the resolvers.</li> </ol> <pre><code>register_custom_resolvers(**resolvers)\n</code></pre> <ol> <li>Provide the reference to where our config file will be (<code>.</code>) and the name without extension (<code>config</code>).</li> </ol> <pre><code>config_fname = \"config\"\nconfig_dir = \".\"\n</code></pre> <ol> <li>Use the Hydra decorator on your main function.    Within the main function scope, you'll have access to the configuration values stored in <code>cfg</code>.</li> </ol> <pre><code>@hydra.main(version_base=None, config_path=config_dir, config_name=config_fname)\ndef main(cfg: DictConfig):\n    print(cfg[\"secret\"])\n</code></pre> <p>Alternative without decorator</p> <p>In case that you don't want to use the decorator <code>@hydra.main</code> and a main function, you can alternatively use. <pre><code>from hydra.utils import instantiate\nfrom hydra import compose, initialize\n\n... # your other code\n\ninitialize(config_path=\".\")\ncfg_raw = compose(config_name=\"config\")  # Load and merge\ncfg = instantiate(cfg_raw)               # Interpolate values\n</code></pre></p>"},{"location":"users-guide/integration-hydra/#configuration-file","title":"Configuration file","text":"<p>On the same level as the <code>main.py</code>, create a <code>config.yaml</code>.</p> <pre><code>param1: 1\nparam2: \"value\"\nsecret: \"${get_aws_secret:/projectBlue/envA/secret}\"\n</code></pre>"},{"location":"users-guide/integration-hydra/#run-the-script","title":"Run the script","text":"<p>If you run your script, you should be able to see your secret printed.</p> <pre><code>python main.py\n</code></pre> <p>By following these steps, you can integrate Hydra into your Python projects and leverage AWS services effectively to retrieve your secrets and parameters securely.</p>"},{"location":"users-guide/quickstart/","title":"Quickstart","text":""},{"location":"users-guide/quickstart/#introduction-to-omegaconf","title":"Introduction to OmegaConf","text":"<p>For those unfamiliar with OmegaConf, it is highly recommended to first review its official documentation. In brief, OmegaConf is a YAML-based configuration system that supports merging configurations from multiple sources.</p> <p>One of OmegaConf's most compelling features is its ability to interpolate values within configuration files. This is achieved through the use of Resolvers. The syntax for interpolation is: <code>\"${&lt;resolver-name&gt;:&lt;args&gt;}\"</code>.</p> <p>Resolvers can be any type of function. Below is an example demonstrating how to register and use a custom resolver:</p> <pre><code>from omegaconf import OmegaConf\n\nOmegaConf.register_new_resolver(\"upper\", lambda x: x.upper())\n\nconf = OmegaConf.create({\n    \"greet\": \"hello\",\n    \"who\": \"${upper:world}\"\n})\nprint(conf[\"who\"])  # 'WORLD'\n</code></pre> <p>Alternatively use <code>register_custom_resolvers</code>, which allows you to register many resolvers at once. They key of the dictionary is the name of the resolver which you need to use to interpolate.</p> <pre><code>from omegaconf import OmegaConf\nfrom omegaconf_cloud_resolvers import register_custom_resolvers\n\nresolvers = {\n    \"upper\": lambda x: x.upper(),\n    \"add_exc\": lambda x: x + \"!\",\n}\nregister_custom_resolvers(**resolvers)\n\nconf = OmegaConf.create({\n    \"greet\": \"hello\",\n    \"who\": \"${add_exc:${upper:world}}\"\n})\nprint(conf[\"who\"])  # 'WORLD!'\n</code></pre> <p>Continue to Cloud Resolvers to see what the plugin can do.</p>"},{"location":"users-guide/resolvers/","title":"Cloud Resolvers","text":"<p>Each resolver uses the same interface but has unique features based on the service it connects to. The next sections will cover important examples for each resolver.</p>","tags":["AWS","AZ","GCP"]},{"location":"users-guide/resolvers/#aws","title":"AWS","text":"","tags":["AWS","AZ","GCP"]},{"location":"users-guide/resolvers/#prerequisites","title":"Prerequisites","text":"<p>The AWS resolvers in this package are built on top of the <code>boto3</code> library, which is the Amazon Web Services (AWS) SDK for Python.</p> <p>If you are running this example from your local machine, ensure that you have configured your AWS credentials.</p> <p>You might need to install the aws-cli if you don't have it yet.</p> <p>After installing the AWS CLI, configure it with your credentials by running:</p> <pre><code>aws configure\n</code></pre> <p>This configuration is stored in the <code>~/.aws/credentials</code> and <code>~/.aws/config</code> files.</p>","tags":["AWS","AZ","GCP"]},{"location":"users-guide/resolvers/#secrets-manager","title":"Secrets Manager","text":"","tags":["AWS","AZ","GCP"]},{"location":"users-guide/resolvers/#create-a-secret","title":"Create a secret","text":"<p>Policy Check</p> <p>If you have problems creating or accessing your secrets,  verify that you have the necessary permissions to access the AWS Secrets Manager. Review the policies needed and ensure that your IAM user or role has the appropriate permissions.</p> <p>You can create a secret using the AWS CLI or the AWS Management Console. Below is an example of how to create a secret using the AWS CLI:</p> <pre><code>aws secretsmanager create-secret --name db_secret_1 --secret-string '{\"user\":\"user1\",\"password\":\"mypassword\"}'\n</code></pre>","tags":["AWS","AZ","GCP"]},{"location":"users-guide/resolvers/#using-the-secrets-manager-resolver","title":"Using the Secrets Manager Resolver","text":"<p>In this example, the <code>AWSSecretsManagerResolver</code> is used to fetch the secret named <code>db_secret_1</code> from AWS Secrets Manager. The <code>infer_json</code> parameter is set to <code>True</code>, which means the resolver will attempt to parse the secret string into a dictionary. This is of interest when the secret stores key:values pairs. If <code>infer_json</code> is set to <code>False</code>, the secret will be returned as a plain string, which is useful if you store a secret string, like a JWT.</p> <p>The following example shows how to use the AWS Secrets Manager resolver with default AWS credentials configuration.</p> <pre><code>from omegaconf import OmegaConf\nfrom omegaconf_cloud_resolvers import register_custom_resolvers\nfrom omegaconf_cloud_resolvers.resolvers.aws import AWSSecretsManagerResolver\n\nresolvers = {\n    \"aws_secretsmanager\": AWSSecretsManagerResolver(infer_json=True),\n}\nregister_custom_resolvers(**resolvers)\n\nconf = OmegaConf.create({\n    \"secret\": \"${aws_secretsmanager:db_secret_1}\"\n})\nprint(conf[\"user\"])  # 'user1'\nprint(conf[\"password\"])  # 'mypassword'\n</code></pre> <p>To check the class in depth, visit the reference page for <code>AWSSecretsManagerResolver</code>.</p>","tags":["AWS","AZ","GCP"]},{"location":"users-guide/resolvers/#ssm-parameter-store","title":"SSM Parameter Store","text":"","tags":["AWS","AZ","GCP"]},{"location":"users-guide/resolvers/#create-parameters","title":"Create parameters","text":"<p>Policy Check</p> <p>If you have problems creating or accessing your parameters, verify that you have the necessary permissions to access the SSM Parameter Store. Review the policies needed and ensure that your IAM user or role has the appropriate permissions.</p> <p>You can create secrets using either the AWS Command Line Interface (CLI) or the AWS Management Console. Below are the instructions for using the CLI:</p> <pre><code>aws ssm put-parameter --name \"/project1/env1/sec\" --value \"MySecureParameterValue\" --type \"SecureString\"\naws ssm put-parameter --name \"/project1/env1/list\" --value \"Value1,Value2,1,1.2\" --type \"StringList\"\naws ssm put-parameter --name \"/project1/env1/famA/a\" --value \"ValueA\" --type \"String\"\naws ssm put-parameter --name \"/project1/env1/famA/b\" --value \"ValueB\" --type \"SecureString\"\n</code></pre>","tags":["AWS","AZ","GCP"]},{"location":"users-guide/resolvers/#using-the-ssm-parameter-store-resolver","title":"Using the SSM Parameter Store Resolver","text":"<p>The <code>AWSParameterStoreResolver</code> is able to retrieve each one of the parameters types available:</p> <ul> <li><code>String</code>: plain string, suitable for common values.</li> <li><code>StringList</code>: comma separated list of plain strings, suitable for a collection of non-encrypted values.</li> <li><code>SecureString</code>: encrypted string, suitable to store sensitive information.   Use the argument <code>decrypt=True</code> (defaults to <code>True</code>) if you need the decrypted value stored, otherwise you will get   the encrypted value.</li> </ul> <p>Another feature of the class is its ability to retrieve nested parameters. The options are:  * <code>/my/param</code>: retrieves one single value.  * <code>/my/param/*</code>: retrieves <code>/my/param</code> and the first level hanging from <code>/my/param/</code>, i.e. <code>/my/param/a</code> and    <code>/my/param/b</code>, as a dictionary: <code>{'param': ..., 'param/a': ...,'param/b': ...}</code>.  * <code>/my/param/family</code>: retrieves <code>/my/param/family</code> and the all the parameters hanging from <code>/my/param/family</code>, i.e. <code>/my/param/family/a</code>,    <code>/my/param/family/a/beta</code> and <code>/my/param/family/b</code>, as a dictionary:    <code>{'family': ..., 'family/a': ..., family/a/beta: ..., 'family/b': ...}</code>.</p> <p>Lastly, <code>infer_types=True</code> will attempt to cast each value to the right type (). That could be of special interest when the parameter type is <code>StringList</code>.</p> <p>The following case assumes that you have default configuration for your AWS credentials.</p> <pre><code>import boto3\nfrom omegaconf import OmegaConf\nfrom omegaconf_cloud_resolvers import register_custom_resolvers\nfrom omegaconf_cloud_resolvers.resolvers.aws import AWSParameterStoreResolver\n\nsession = boto3.Session(profile_name=\"&lt;my-profile&gt;\")\n\nresolvers = {\n    # Decrypts and infer the parameter. It will return a single value.\n    \"get_aws_param\": AWSParameterStoreResolver(session=session, decrypt=True, infer_types=True),\n    # This parameter is a list of elements, that does not require decryption. It will return a list[any]\n    \"get_aws_param_list\": AWSParameterStoreResolver(session=session, decrypt=False, infer_types=True),\n    # This parameter is a list of elements, that does not require decryption. It will return a list[str]\n    \"get_aws_param_list_str\": AWSParameterStoreResolver(session=session, decrypt=False, infer_types=False),\n}\n\nregister_custom_resolvers(**resolvers)\n\nconf = OmegaConf.create({\n    \"sec_param\":  \"${get_aws_param:/project1/env1/sec}\",\n    \"collection_param\": \"${get_aws_param:/project1/env1/famA/*}\",\n    \"list_param\": \"${get_aws_param_list:/project1/env1/list}\",\n    \"list_param_str\": \"${get_aws_param_list_str:/project1/env1/list}\",\n})\n\nprint(conf[\"sec_param\"])\nprint(conf[\"collection_param\"])\nprint(conf[\"list_param\"])\nprint(conf[\"list_param_str\"])\n</code></pre> <p>To check the class in depth, visit the reference page for <code>AWSParameterStoreResolver</code>.</p>","tags":["AWS","AZ","GCP"]},{"location":"users-guide/resolvers/#azure","title":"Azure","text":"","tags":["AWS","AZ","GCP"]},{"location":"users-guide/resolvers/#prerequisites_1","title":"Prerequisites","text":"<p>If you need to test locally your configuration you will need to install the Azure CLI.</p> <p>Make sure as well that you are authenticated:</p> <pre><code>az login\n</code></pre>","tags":["AWS","AZ","GCP"]},{"location":"users-guide/resolvers/#key-vault","title":"Key Vault","text":"","tags":["AWS","AZ","GCP"]},{"location":"users-guide/resolvers/#create-a-secret_1","title":"Create a Secret","text":"<p>You need to point out to a secret. In case that you need to create a new one, you can create it using the console or through the web.</p> <p>Key Vaults</p> <p>Key Vault's secrets belong inside objects called Key Vaults. As anything in Azure, they must be linked to a resource group, so make sure that you have a resource group available. In case you don't, you can create a new one: <pre><code>az group create --name &lt;ResourceGroupName&gt; --location germanywestcentral\n</code></pre> To create a Key Vault run: <pre><code>az keyvault create --name &lt;ConfigVaultName&gt; --resource-group &lt;ResourceGroupName&gt; --location germanywestcentral\n</code></pre></p> <p>Let's create 2 versions for this secret, make sure that you replace the fields between <code>&lt;&gt;</code> by the proper strings. <pre><code>az keyvault secret set --vault-name &lt;ConfigVaulName&gt; --name MySecret --value \"This is a s3cr3t\"\naz keyvault secret set --vault-name &lt;ConfigVaulName&gt; --name MySecret --value \"This is a s3cr3t v2\"\n</code></pre></p> <p>Permission error creating a secret</p> <p>If you get an error trying to create the secrets like: <code>` it is likely that you don't have the right set of permissions to create secrets. For this example's sake, you can use the</code>Key Vault Administrator` role. Add the previusly mentioned role in your ConfigResourceGroup/Access control (IAM)/Role Assigments as described here. Consider using a more restricted role in production.</p> <p>Key Vault naming</p> <p>Key Vault naming must be globally unique, so you can add some random string at the end of the name if you get any related error.</p>","tags":["AWS","AZ","GCP"]},{"location":"users-guide/resolvers/#using-the-azure-key-vault-resolver","title":"Using the Azure Key Vault Resolver","text":"<p>The Azure Key Vault resolver support the one name parameter. The supported patterns are:  * <code>keyvault/&lt;keyvault-name&gt;/secret/&lt;secret-name&gt;/version/&lt;version-id&gt;</code>: retrieves a given secret version.  * <code>keyvault/&lt;keyvault-name&gt;/secret/&lt;secret-name&gt;</code>: retrieves the latest version of a secret.</p> <p>Assuming that in my case I have access to  * Key Vault: <code>ConfigVaultu31d</code> (in your case it will be different)  * Secret: <code>MySecret</code></p> <pre><code>from omegaconf import OmegaConf\nfrom omegaconf_cloud_resolvers import register_custom_resolvers\nfrom omegaconf_cloud_resolvers.resolvers.az import AzureKeyVaultResolver\nfrom azure.identity import DefaultAzureCredential\n\ncredentials = DefaultAzureCredential()\n\nresolvers = {\n    \"get_az_secret\": AzureKeyVaultResolver(credentials=credentials),\n}\n\nregister_custom_resolvers(**resolvers)\n\nconf = OmegaConf.create({\n    \"secret_01\":\"${get_az_secret:keyvault/ConfigVaultu31d/secret/MySecret}\",\n    \"secret_02\":\"${get_az_secret:keyvault/ConfigVaultu31d/secret/MySecret/version/339c8635b01644b2b6197588ef94a228}\",\n    \"secret_03\":\"${get_az_secret:keyvault/ConfigVaultu31d/secret/MySecret/version/ab9a2a6ae5b5420abd49a71628f368d8}\",\n})\n\nprint(conf[\"secret_01\"])\nprint(conf[\"secret_02\"])\nprint(conf[\"secret_03\"])\n</code></pre>","tags":["AWS","AZ","GCP"]},{"location":"users-guide/resolvers/#gcp","title":"GCP","text":"","tags":["AWS","AZ","GCP"]},{"location":"users-guide/resolvers/#prerequisites_2","title":"Prerequisites","text":"<p>If you are working on your local environment, ensure that you have the necessary permissions and tools installed to interact with Google Cloud Platform services, in this case, the Secret Manager.</p> <p>You will need the <code>gcloud</code> CLI installed and authenticated to your GCP account. Set-up the environment credentials and make sure that you have the right access permissions.</p> <p>If you want to set up Application Default Credentials (ADC), so your application automatically finds your environment credentials, review this link.</p>","tags":["AWS","AZ","GCP"]},{"location":"users-guide/resolvers/#secret-manager","title":"Secret Manager","text":"","tags":["AWS","AZ","GCP"]},{"location":"users-guide/resolvers/#create-a-secret_2","title":"Create a Secret","text":"<p>Create a secret through the web or using the <code>gcloud</code> CLI, running the line below.</p> <pre><code>echo -n \"This is a s3cr3t\" | gcloud secrets create gcp-secret-001 --data-file=-\n</code></pre> <p>Also create a new version for this example.</p> <pre><code>echo -n \"This is a s3cr3t v2\" | gcloud secrets versions add gcp-secret-001 --data-file=-\n</code></pre>","tags":["AWS","AZ","GCP"]},{"location":"users-guide/resolvers/#using-the-gcp-secret-manager-resolver","title":"Using the GCP Secret Manager Resolver","text":"<p>The typical way to access a  GCP secret is providing a combination of the project_id, the secret id and, optionally, the secret's version. That is supported by the resolver, allowing you to retrieve the secret providing a name under the following format:</p> <ul> <li><code>project/&lt;project_id&gt;/secrets/&lt;secret_id&gt;/versions/&lt;version&gt;</code></li> <li><code>project/&lt;project_id&gt;/secrets/&lt;secret_id&gt;</code>: retrieve the latest version</li> <li><code>secrets/&lt;secret_id&gt;/versions/&lt;version&gt;</code>: infer the project_id based on the default configuration</li> <li><code>secrets/&lt;secret_id&gt;</code>: infer the project_id based on the default configuration and retrieve the latest version</li> <li><code>&lt;secret_id&gt;</code>: infer the project_id based on the default configuration and retrieve the latest version</li> </ul> <p>Assuming that you have the ADC, create a file <code>main.py</code> like the following:</p> <pre><code>from omegaconf import OmegaConf\nfrom omegaconf_cloud_resolvers import register_custom_resolvers\nfrom omegaconf_cloud_resolvers.resolvers.gcp import GCPSecretManagerResolver\n\nresolvers = {\n    \"get_gcp_secret\": GCPSecretManagerResolver(),   # if you don't have the ADC, or you need to override the,\n                                                    # provide: credentials and project_id\n}\nregister_custom_resolvers(**resolvers)\n\nconf = OmegaConf.create({\n    \"secret_01\": \"${get_gcp_secret:secrets/gcp-secret-001/versions/1}\",\n    \"secret_02\": \"${get_gcp_secret:secrets/gcp-secret-001}\",\n    \"secret_03\": \"${get_gcp_secret:gcp-secret-001}\",\n})\n\nprint(conf[\"secret_01\"])\nprint(conf[\"secret_02\"])\nprint(conf[\"secret_03\"])\n</code></pre>","tags":["AWS","AZ","GCP"]},{"location":"tags/","title":"Tags","text":"<p>List of relevant tags:</p>"},{"location":"tags/#aws","title":"AWS","text":"<ul> <li>Parameter Store</li> <li>Secrets Manager</li> <li>Cloud Resolvers</li> </ul>"},{"location":"tags/#az","title":"AZ","text":"<ul> <li>KeyVault</li> <li>Cloud Resolvers</li> </ul>"},{"location":"tags/#gcp","title":"GCP","text":"<ul> <li>Secret Manager</li> <li>Cloud Resolvers</li> </ul>"}]}